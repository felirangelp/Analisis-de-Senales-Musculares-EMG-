<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lisis de Se√±ales Musculares (EMG) para Clasificar y Reconocer Diferentes Movimientos</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .header-content {
            flex: 1;
            min-width: 300px;
        }
        
        .header-logo {
            flex-shrink: 0;
        }
        
        .header-logo img {
            max-width: 120px;
            height: auto;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .header-info {
            margin-top: 15px;
            color: #666;
            font-size: 14px;
            line-height: 1.8;
        }
        
        .header-info strong {
            color: #667eea;
            font-weight: 600;
        }
        
        .tabs {
            background: white;
            padding: 0;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            overflow-x: auto;
        }
        
        .tab-button {
            padding: 15px 30px;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        
        .tab-button:hover {
            background: #e0e0e0;
        }
        
        .tab-button.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }
        
        .tab-content {
            display: none;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            margin-bottom: 40px;
        }
        
        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .plot-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .analysis-box {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }
        
        .conclusion-box {
            background: #f0f8e8;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #4caf50;
        }
        
        .matrix-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
            width: 100%;
        }
        
        @media (max-width: 1200px) {
            .matrix-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .matrix-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .matrix-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .matrix-item h4 {
            text-align: center;
            margin-bottom: 10px;
            color: #667eea;
            font-size: 16px;
            font-weight: bold;
        }
        
        .matrix-item > div {
            flex: 1;
            width: 100%;
            min-height: 300px;
        }
        
        .matrix-item .svg-container {
            width: 100% !important;
            height: 100% !important;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #667eea;
        }
        
        .classification-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        
        .classification-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        table th, table td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        table th {
            background: #667eea;
            color: white;
        }
        
        table tr:nth-child(even) {
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <h1>üìä An√°lisis de Se√±ales Musculares (EMG) para Clasificar y Reconocer Diferentes Movimientos</h1>
                <p>An√°lisis completo de se√±ales electromiogr√°ficas de superficie</p>
                <div class="header-info">
                    <div><strong>Felipe Rangel Perez</strong></div>
                    <div>Procesamiento de Se√±ales Biol√≥gicas</div>
                    <div>Pontificia Universidad Javeriana</div>
                </div>
            </div>
            <div class="header-logo">
                <img src="https://www.javeriana.edu.co/recursosdb/20125/5571273/escudo-circular.png" alt="Logo Pontificia Universidad Javeriana">
            </div>
        </header>
        
        <div class="tabs">
            <button class="tab-button active" onclick="showTab('movement1')">Movimiento 1</button>
            <button class="tab-button" onclick="showTab('movement2')">Movimiento 2</button>
            <button class="tab-button" onclick="showTab('movement3')">Movimiento 3</button>
            <button class="tab-button" onclick="showTab('classification')">Clasificaci√≥n</button>
        </div>
        
        <div id="loading" class="loading">
            Cargando datos...
        </div>
        
        <div id="content" style="display: none;">
            <!-- Pesta√±a Movimiento 1 -->
            <div id="movement1" class="tab-content active">
                <div class="section">
                    <h2>Punto 1: Filtrado Pasabanda 100-200 Hz</h2>
                    <div class="plot-container">
                        <div id="plot1_1"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>El filtrado pasabanda entre 100-200 Hz elimina componentes de frecuencia fuera del rango de inter√©s t√≠pico de se√±ales EMG. Este filtro ayuda a reducir el ruido de l√≠nea base, artefactos de movimiento y componentes de baja frecuencia, preservando la informaci√≥n relevante de la actividad muscular en el rango espectral donde se concentra la mayor parte de la energ√≠a de las se√±ales EMG de superficie.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 2: Transformada de Hilbert</h2>
                    <div class="plot-container">
                        <div id="plot1_2"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La transformada de Hilbert convierte la se√±al real en una se√±al anal√≠tica compleja. La parte real corresponde a la se√±al original filtrada, mientras que la parte imaginaria es la transformada de Hilbert propiamente dicha. Esta transformaci√≥n permite calcular la envolvente (amplitud instant√°nea) y la fase instant√°nea de la se√±al, que son fundamentales para el an√°lisis de conectividad entre canales.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 3: Envolvente y Fase Instant√°nea</h2>
                    <div class="plot-container">
                        <div id="plot1_3"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La envolvente representa la amplitud modulada de la se√±al EMG, capturando la variaci√≥n temporal de la intensidad de la actividad muscular. La fase instant√°nea contiene informaci√≥n sobre la sincronizaci√≥n temporal y permite identificar relaciones de fase entre diferentes canales, lo cual es crucial para el an√°lisis de conectividad funcional entre grupos musculares.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 4: Divisi√≥n en Ventanas de 10 segundos</h2>
                    <div class="plot-container">
                        <div id="plot1_4"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La segmentaci√≥n temporal divide la se√±al continua en ventanas de 10 segundos, generando 17 eventos por movimiento. Esta segmentaci√≥n permite analizar la variabilidad temporal de las caracter√≠sticas de la se√±al EMG y realizar an√°lisis estad√≠sticos sobre cada ventana de tiempo, facilitando la identificaci√≥n de patrones y cambios en la actividad muscular.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 5: Correlaci√≥n y Sincronizaci√≥n de Fase</h2>
                    <div class="plot-container">
                        <div id="plot1_5"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La correlaci√≥n de amplitud mide la similitud en la modulaci√≥n de amplitud entre pares de canales, mientras que la sincronizaci√≥n de fase (PLV - Phase Locking Value) cuantifica el grado de sincronizaci√≥n de fase entre canales. Valores altos de correlaci√≥n y PLV indican actividad muscular coordinada entre los canales correspondientes.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 6: Matrices de Conectividad</h2>
                    <div class="plot-container">
                        <div id="plot1_6"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>Las matrices de conectividad 4√ó4 representan las relaciones entre los 4 canales EMG para cada evento. La diagonal siempre es 1 (autocorrelaci√≥n), y los valores fuera de la diagonal muestran la conectividad entre pares de canales. Estas matrices capturan la estructura de conectividad funcional en cada ventana temporal.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 7: Vector de Caracter√≠sticas</h2>
                    <div class="plot-container">
                        <div id="plot1_7"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>Las caracter√≠sticas se extraen del tri√°ngulo superior de cada matriz de conectividad 4√ó4, resultando en 6 caracter√≠sticas por tipo (amplitud y fase). Esto reduce la dimensionalidad eliminando redundancia (la matriz es sim√©trica) y mantiene toda la informaci√≥n de conectividad entre canales para su uso en clasificaci√≥n.</p>
                    </div>
                </div>
            </div>
            
            <!-- Pesta√±a Movimiento 2 -->
            <div id="movement2" class="tab-content">
                <div class="section">
                    <h2>Punto 1: Filtrado Pasabanda 100-200 Hz</h2>
                    <div class="plot-container">
                        <div id="plot2_1"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>El filtrado pasabanda entre 100-200 Hz elimina componentes de frecuencia fuera del rango de inter√©s t√≠pico de se√±ales EMG. Este filtro ayuda a reducir el ruido de l√≠nea base, artefactos de movimiento y componentes de baja frecuencia, preservando la informaci√≥n relevante de la actividad muscular.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 2: Transformada de Hilbert</h2>
                    <div class="plot-container">
                        <div id="plot2_2"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La transformada de Hilbert convierte la se√±al real en una se√±al anal√≠tica compleja, permitiendo calcular la envolvente y la fase instant√°nea de la se√±al.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 3: Envolvente y Fase Instant√°nea</h2>
                    <div class="plot-container">
                        <div id="plot2_3"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La envolvente representa la amplitud modulada de la se√±al EMG, mientras que la fase instant√°nea contiene informaci√≥n sobre la sincronizaci√≥n temporal entre canales.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 4: Divisi√≥n en Ventanas de 10 segundos</h2>
                    <div class="plot-container">
                        <div id="plot2_4"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La segmentaci√≥n temporal divide la se√±al continua en ventanas de 10 segundos, generando 17 eventos por movimiento.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 5: Correlaci√≥n y Sincronizaci√≥n de Fase</h2>
                    <div class="plot-container">
                        <div id="plot2_5"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La correlaci√≥n de amplitud y la sincronizaci√≥n de fase (PLV) cuantifican las relaciones entre pares de canales.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 6: Matrices de Conectividad</h2>
                    <div class="plot-container">
                        <div id="plot2_6"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>Las matrices de conectividad 4√ó4 representan las relaciones entre los 4 canales EMG para cada evento.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 7: Vector de Caracter√≠sticas</h2>
                    <div class="plot-container">
                        <div id="plot2_7"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>Las caracter√≠sticas se extraen del tri√°ngulo superior de cada matriz de conectividad, resultando en 6 caracter√≠sticas por tipo.</p>
                    </div>
                </div>
            </div>
            
            <!-- Pesta√±a Movimiento 3 -->
            <div id="movement3" class="tab-content">
                <div class="section">
                    <h2>Punto 1: Filtrado Pasabanda 100-200 Hz</h2>
                    <div class="plot-container">
                        <div id="plot3_1"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>El filtrado pasabanda entre 100-200 Hz elimina componentes de frecuencia fuera del rango de inter√©s t√≠pico de se√±ales EMG.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 2: Transformada de Hilbert</h2>
                    <div class="plot-container">
                        <div id="plot3_2"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La transformada de Hilbert convierte la se√±al real en una se√±al anal√≠tica compleja.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 3: Envolvente y Fase Instant√°nea</h2>
                    <div class="plot-container">
                        <div id="plot3_3"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La envolvente representa la amplitud modulada de la se√±al EMG, mientras que la fase instant√°nea contiene informaci√≥n sobre la sincronizaci√≥n temporal.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 4: Divisi√≥n en Ventanas de 10 segundos</h2>
                    <div class="plot-container">
                        <div id="plot3_4"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La segmentaci√≥n temporal divide la se√±al continua en ventanas de 10 segundos, generando 17 eventos por movimiento.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 5: Correlaci√≥n y Sincronizaci√≥n de Fase</h2>
                    <div class="plot-container">
                        <div id="plot3_5"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La correlaci√≥n de amplitud y la sincronizaci√≥n de fase (PLV) cuantifican las relaciones entre pares de canales.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 6: Matrices de Conectividad</h2>
                    <div class="plot-container">
                        <div id="plot3_6"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>Las matrices de conectividad 4√ó4 representan las relaciones entre los 4 canales EMG para cada evento.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Punto 7: Vector de Caracter√≠sticas</h2>
                    <div class="plot-container">
                        <div id="plot3_7"></div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>Las caracter√≠sticas se extraen del tri√°ngulo superior de cada matriz de conectividad, resultando en 6 caracter√≠sticas por tipo.</p>
                    </div>
                </div>
            </div>
            
            <!-- Pesta√±a Clasificaci√≥n -->
            <div id="classification" class="tab-content">
                <div class="section">
                    <h2>Punto 8: Clasificaci√≥n de Movimientos</h2>
                    <div class="classification-grid">
                        <div class="classification-item">
                            <h3>PCA - An√°lisis de Componentes Principales</h3>
                            <div id="plot_classification_pca"></div>
                        </div>
                        <div class="classification-item">
                            <h3>t-SNE - Reducci√≥n de Dimensionalidad No Lineal</h3>
                            <div id="plot_classification_tsne"></div>
                        </div>
                        <div class="classification-item">
                            <h3>Matriz de Confusi√≥n</h3>
                            <div id="plot_classification_cm"></div>
                        </div>
                        <div class="classification-item">
                            <h3>Reporte de Clasificaci√≥n</h3>
                            <div id="plot_classification_report"></div>
                        </div>
                    </div>
                    <div class="analysis-box">
                        <h3>üìà An√°lisis</h3>
                        <p>La clasificaci√≥n utiliza un clasificador SVM (Support Vector Machine) con kernel RBF (Radial Basis Function) para distinguir entre los tres movimientos bas√°ndose en las caracter√≠sticas de conectividad extra√≠das. El an√°lisis PCA muestra la separabilidad de las clases en un espacio de dimensionalidad reducida, mientras que t-SNE proporciona una visualizaci√≥n no lineal que puede revelar estructuras m√°s complejas en los datos. La matriz de confusi√≥n y el reporte de clasificaci√≥n proporcionan m√©tricas detalladas del rendimiento del clasificador.</p>
                    </div>
                    <div class="conclusion-box">
                        <h3>‚úÖ Conclusi√≥n</h3>
                        <p>El alto accuracy obtenido (93.75%) demuestra que las caracter√≠sticas de conectividad (correlaci√≥n de amplitud y sincronizaci√≥n de fase) son efectivas para distinguir entre diferentes movimientos. Cada movimiento tiene un patr√≥n √∫nico de conectividad muscular que puede ser identificado mediante estas caracter√≠sticas, lo cual es valioso para aplicaciones de reconocimiento de gestos y control de pr√≥tesis.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let data = null;
        let plotsRendered = {
            movement1: false,
            movement2: false,
            movement3: false,
            classification: false
        };
        
        // Cargar datos
        fetch('data.json')
            .then(response => response.json())
            .then(jsonData => {
                data = jsonData;
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
                
                // Renderizar primera pesta√±a
                renderMovement1();
            })
            .catch(error => {
                console.error('Error cargando datos:', error);
                document.getElementById('loading').innerHTML = 'Error cargando datos. Aseg√∫rate de ejecutar process_emg.py primero.';
            });
        
        function showTab(tabName) {
            // Ocultar todas las pesta√±as
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Mostrar pesta√±a seleccionada
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // Renderizar gr√°ficas si no se han renderizado
            if (tabName === 'movement1' && !plotsRendered.movement1) {
                renderMovement1();
            } else if (tabName === 'movement2' && !plotsRendered.movement2) {
                renderMovement2();
            } else if (tabName === 'movement3' && !plotsRendered.movement3) {
                renderMovement3();
            } else if (tabName === 'classification' && !plotsRendered.classification) {
                renderClassification();
            }
        }
        
        function createTimeVector(nSamples, Fs, sampleRate) {
            return Array.from({length: nSamples}, (_, i) => i * sampleRate / Fs);
        }
        
        function renderMovement1() {
            if (!data || plotsRendered.movement1) return;
            const mov = data.movements.movement1;
            const Fs = data.Fs;
            const sampleRate = data.sample_rate;
            const time = createTimeVector(mov.original_signal.length, Fs, sampleRate);
            
            // Plot 1_1: Filtrado
            const traces1_1 = [];
            const colors = ['blue', 'red', 'green', 'orange'];
            for (let ch = 0; ch < 4; ch++) {
                traces1_1.push({
                    x: time,
                    y: mov.original_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Original`,
                    line: {color: colors[ch], width: 1}
                });
                traces1_1.push({
                    x: time,
                    y: mov.filtered_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Filtrado`,
                    line: {color: colors[ch], width: 1, dash: 'dash'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot1_1', traces1_1, {
                title: 'Punto 1: Se√±al Original vs Filtrada (100-200 Hz)',
                xaxis: {title: 'Tiempo (s)', domain: [0, 1]},
                yaxis: {title: 'Amplitud Original', side: 'left'},
                yaxis2: {title: 'Amplitud Filtrada', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 1_2: Transformada de Hilbert
            const traces1_2 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces1_2.push({
                    x: time,
                    y: mov.analytic_signal_real.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Real`,
                    line: {color: colors[ch], width: 1}
                });
                traces1_2.push({
                    x: time,
                    y: mov.analytic_signal_imag.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Imaginaria`,
                    line: {color: colors[ch], width: 1, dash: 'dot'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot1_2', traces1_2, {
                title: 'Punto 2: Transformada de Hilbert (Parte Real e Imaginaria)',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Parte Real', side: 'left'},
                yaxis2: {title: 'Parte Imaginaria', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 1_3: Envolvente y Fase
            const traces1_3 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces1_3.push({
                    x: time,
                    y: mov.envelope.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Envolvente`,
                    line: {color: colors[ch], width: 2}
                });
                traces1_3.push({
                    x: time,
                    y: mov.phase.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Fase`,
                    line: {color: colors[ch], width: 1, dash: 'dash'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot1_3', traces1_3, {
                title: 'Punto 3: Envolvente y Fase Instant√°nea',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Envolvente', side: 'left'},
                yaxis2: {title: 'Fase (rad)', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 1_4: Segmentaci√≥n
            const traces1_4 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces1_4.push({
                    x: time,
                    y: mov.filtered_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1}`,
                    line: {color: colors[ch], width: 1}
                });
            }
            const shapes = [];
            for (let i = 1; i < mov.n_events; i++) {
                shapes.push({
                    type: 'line',
                    x0: i * 10,
                    x1: i * 10,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {color: 'gray', width: 2, dash: 'dash'}
                });
            }
            Plotly.newPlot('plot1_4', traces1_4, {
                title: `Punto 4: Divisi√≥n en ${mov.n_events} Ventanas de 10 segundos`,
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Amplitud'},
                shapes: shapes,
                hovermode: 'closest'
            });
            
            // Plot 1_5: Correlaci√≥n y Sincronizaci√≥n
            const channelPairs = ['1-2', '1-3', '1-4', '2-3', '2-4', '3-4'];
            const ampValues = [];
            const phaseValues = [];
            for (let e = 0; e < mov.n_events; e++) {
                const ampRow = [];
                const phaseRow = [];
                const pairs = [[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]];
                pairs.forEach(([ch1, ch2]) => {
                    ampRow.push(mov.amp_connectivity[e][ch1][ch2]);
                    phaseRow.push(mov.phase_connectivity[e][ch1][ch2]);
                });
                ampValues.push(ampRow);
                phaseValues.push(phaseRow);
            }
            
            const traces1_5_amp = channelPairs.map((pair, idx) => ({
                x: Array.from({length: mov.n_events}, (_, i) => i + 1),
                y: ampValues.map(row => row[idx]),
                type: 'scatter',
                mode: 'lines+markers',
                name: `Amp ${pair}`
            }));
            
            const traces1_5_phase = channelPairs.map((pair, idx) => ({
                x: Array.from({length: mov.n_events}, (_, i) => i + 1),
                y: phaseValues.map(row => row[idx]),
                type: 'scatter',
                mode: 'lines+markers',
                name: `Fase ${pair}`,
                yaxis: 'y2'
            }));
            
            Plotly.newPlot('plot1_5', [...traces1_5_amp, ...traces1_5_phase], {
                title: 'Punto 5: Correlaci√≥n de Amplitud y Sincronizaci√≥n de Fase',
                xaxis: {title: 'Ventana Temporal'},
                yaxis: {title: 'Correlaci√≥n de Amplitud', side: 'left'},
                yaxis2: {title: 'PLV', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 1_6: Matrices de Conectividad (grid)
            const matrixDiv = document.getElementById('plot1_6');
            if (matrixDiv) {
                matrixDiv.innerHTML = '<div class="matrix-grid"></div>';
                const grid = matrixDiv.querySelector('.matrix-grid');
                
                if (grid && mov.amp_connectivity) {
                    for (let e = 0; e < mov.n_events; e++) {
                        const item = document.createElement('div');
                        item.className = 'matrix-item';
                        const matrixId = `matrix1_${e}`;
                        item.innerHTML = `<h4>Evento ${e+1}</h4><div id="${matrixId}" style="width: 100%; height: 100%; min-height: 300px;"></div>`;
                        grid.appendChild(item);
                        
                        // Renderizar despu√©s de agregar al DOM
                        setTimeout(() => {
                            Plotly.newPlot(matrixId, [{
                                z: mov.amp_connectivity[e],
                                type: 'heatmap',
                                colorscale: 'Viridis',
                                colorbar: {title: 'Correlaci√≥n', len: 0.6},
                                text: mov.amp_connectivity[e].map(row => 
                                    row.map(val => val.toFixed(2))
                                ),
                                texttemplate: '%{text}',
                                textfont: {size: 12}
                            }], {
                                title: `Evento ${e+1}`,
                                xaxis: {title: 'Canal', tickvals: [0, 1, 2, 3], ticktext: ['1', '2', '3', '4']},
                                yaxis: {title: 'Canal', tickvals: [0, 1, 2, 3], ticktext: ['1', '2', '3', '4']},
                                margin: {l: 60, r: 30, t: 40, b: 60},
                                autosize: true
                            }, {displayModeBar: false, responsive: true});
                        }, 10 * e);
                    }
                }
            }
            
            // Plot 1_7: Vector de Caracter√≠sticas
            Plotly.newPlot('plot1_7', [{
                z: mov.amp_features,
                type: 'heatmap',
                colorscale: 'RdYlBu',
                colorbar: {title: 'Valor'},
                x: channelPairs,
                y: Array.from({length: mov.n_events}, (_, i) => `Evento ${i+1}`)
            }], {
                title: 'Punto 7: Matriz de Caracter√≠sticas (N eventos √ó 6 caracter√≠sticas)',
                xaxis: {title: 'Caracter√≠sticas (Pares de Canales)'},
                yaxis: {title: 'Eventos/Ventanas'}
            });
            
            plotsRendered.movement1 = true;
        }
        
        function renderMovement2() {
            if (!data || plotsRendered.movement2) return;
            const mov = data.movements.movement2;
            const Fs = data.Fs;
            const sampleRate = data.sample_rate;
            const time = createTimeVector(mov.original_signal.length, Fs, sampleRate);
            const colors = ['blue', 'red', 'green', 'orange'];
            const channelPairs = ['1-2', '1-3', '1-4', '2-3', '2-4', '3-4'];
            
            // Similar a movimiento 1 pero con plot2_X
            // Plot 2_1
            const traces2_1 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces2_1.push({
                    x: time,
                    y: mov.original_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Original`,
                    line: {color: colors[ch], width: 1}
                });
                traces2_1.push({
                    x: time,
                    y: mov.filtered_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Filtrado`,
                    line: {color: colors[ch], width: 1, dash: 'dash'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot2_1', traces2_1, {
                title: 'Punto 1: Se√±al Original vs Filtrada (100-200 Hz)',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Amplitud Original', side: 'left'},
                yaxis2: {title: 'Amplitud Filtrada', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 2_2
            const traces2_2 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces2_2.push({
                    x: time,
                    y: mov.analytic_signal_real.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Real`,
                    line: {color: colors[ch], width: 1}
                });
                traces2_2.push({
                    x: time,
                    y: mov.analytic_signal_imag.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Imaginaria`,
                    line: {color: colors[ch], width: 1, dash: 'dot'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot2_2', traces2_2, {
                title: 'Punto 2: Transformada de Hilbert',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Parte Real', side: 'left'},
                yaxis2: {title: 'Parte Imaginaria', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 2_3
            const traces2_3 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces2_3.push({
                    x: time,
                    y: mov.envelope.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Envolvente`,
                    line: {color: colors[ch], width: 2}
                });
                traces2_3.push({
                    x: time,
                    y: mov.phase.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Fase`,
                    line: {color: colors[ch], width: 1, dash: 'dash'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot2_3', traces2_3, {
                title: 'Punto 3: Envolvente y Fase Instant√°nea',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Envolvente', side: 'left'},
                yaxis2: {title: 'Fase (rad)', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 2_4
            const traces2_4 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces2_4.push({
                    x: time,
                    y: mov.filtered_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1}`,
                    line: {color: colors[ch], width: 1}
                });
            }
            const shapes2_4 = [];
            for (let i = 1; i < mov.n_events; i++) {
                shapes2_4.push({
                    type: 'line',
                    x0: i * 10,
                    x1: i * 10,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {color: 'gray', width: 2, dash: 'dash'}
                });
            }
            Plotly.newPlot('plot2_4', traces2_4, {
                title: `Punto 4: Divisi√≥n en ${mov.n_events} Ventanas de 10 segundos`,
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Amplitud'},
                shapes: shapes2_4,
                hovermode: 'closest'
            });
            
            // Plot 2_5
            const ampValues2 = [];
            const phaseValues2 = [];
            for (let e = 0; e < mov.n_events; e++) {
                const ampRow = [];
                const phaseRow = [];
                const pairs = [[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]];
                pairs.forEach(([ch1, ch2]) => {
                    ampRow.push(mov.amp_connectivity[e][ch1][ch2]);
                    phaseRow.push(mov.phase_connectivity[e][ch1][ch2]);
                });
                ampValues2.push(ampRow);
                phaseValues2.push(phaseRow);
            }
            const traces2_5_amp = channelPairs.map((pair, idx) => ({
                x: Array.from({length: mov.n_events}, (_, i) => i + 1),
                y: ampValues2.map(row => row[idx]),
                type: 'scatter',
                mode: 'lines+markers',
                name: `Amp ${pair}`
            }));
            const traces2_5_phase = channelPairs.map((pair, idx) => ({
                x: Array.from({length: mov.n_events}, (_, i) => i + 1),
                y: phaseValues2.map(row => row[idx]),
                type: 'scatter',
                mode: 'lines+markers',
                name: `Fase ${pair}`,
                yaxis: 'y2'
            }));
            Plotly.newPlot('plot2_5', [...traces2_5_amp, ...traces2_5_phase], {
                title: 'Punto 5: Correlaci√≥n y Sincronizaci√≥n de Fase',
                xaxis: {title: 'Ventana Temporal'},
                yaxis: {title: 'Correlaci√≥n de Amplitud', side: 'left'},
                yaxis2: {title: 'PLV', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 2_6
            const matrixDiv2 = document.getElementById('plot2_6');
            if (matrixDiv2) {
                matrixDiv2.innerHTML = '<div class="matrix-grid"></div>';
                const grid2 = matrixDiv2.querySelector('.matrix-grid');
                if (grid2 && mov.amp_connectivity) {
                    for (let e = 0; e < mov.n_events; e++) {
                        const item = document.createElement('div');
                        item.className = 'matrix-item';
                        const matrixId = `matrix2_${e}`;
                        item.innerHTML = `<h4>Evento ${e+1}</h4><div id="${matrixId}" style="width: 100%; height: 100%; min-height: 300px;"></div>`;
                        grid2.appendChild(item);
                        setTimeout(() => {
                            Plotly.newPlot(matrixId, [{
                                z: mov.amp_connectivity[e],
                                type: 'heatmap',
                                colorscale: 'Viridis',
                                colorbar: {title: 'Correlaci√≥n', len: 0.6},
                                text: mov.amp_connectivity[e].map(row => 
                                    row.map(val => val.toFixed(2))
                                ),
                                texttemplate: '%{text}',
                                textfont: {size: 12}
                            }], {
                                title: `Evento ${e+1}`,
                                xaxis: {title: 'Canal', tickvals: [0, 1, 2, 3], ticktext: ['1', '2', '3', '4']},
                                yaxis: {title: 'Canal', tickvals: [0, 1, 2, 3], ticktext: ['1', '2', '3', '4']},
                                margin: {l: 60, r: 30, t: 40, b: 60},
                                autosize: true
                            }, {displayModeBar: false, responsive: true});
                        }, 10 * e);
                    }
                }
            }
            
            // Plot 2_7
            Plotly.newPlot('plot2_7', [{
                z: mov.amp_features,
                type: 'heatmap',
                colorscale: 'RdYlBu',
                colorbar: {title: 'Valor'},
                x: channelPairs,
                y: Array.from({length: mov.n_events}, (_, i) => `Evento ${i+1}`)
            }], {
                title: 'Punto 7: Matriz de Caracter√≠sticas',
                xaxis: {title: 'Caracter√≠sticas (Pares de Canales)'},
                yaxis: {title: 'Eventos/Ventanas'}
            });
            
            plotsRendered.movement2 = true;
        }
        
        function renderMovement3() {
            if (!data || plotsRendered.movement3) return;
            const mov = data.movements.movement3;
            const Fs = data.Fs;
            const sampleRate = data.sample_rate;
            const time = createTimeVector(mov.original_signal.length, Fs, sampleRate);
            const colors = ['blue', 'red', 'green', 'orange'];
            const channelPairs = ['1-2', '1-3', '1-4', '2-3', '2-4', '3-4'];
            
            // Plot 3_1
            const traces3_1 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces3_1.push({
                    x: time,
                    y: mov.original_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Original`,
                    line: {color: colors[ch], width: 1}
                });
                traces3_1.push({
                    x: time,
                    y: mov.filtered_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Filtrado`,
                    line: {color: colors[ch], width: 1, dash: 'dash'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot3_1', traces3_1, {
                title: 'Punto 1: Se√±al Original vs Filtrada (100-200 Hz)',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Amplitud Original', side: 'left'},
                yaxis2: {title: 'Amplitud Filtrada', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 3_2
            const traces3_2 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces3_2.push({
                    x: time,
                    y: mov.analytic_signal_real.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Real`,
                    line: {color: colors[ch], width: 1}
                });
                traces3_2.push({
                    x: time,
                    y: mov.analytic_signal_imag.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Imaginaria`,
                    line: {color: colors[ch], width: 1, dash: 'dot'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot3_2', traces3_2, {
                title: 'Punto 2: Transformada de Hilbert',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Parte Real', side: 'left'},
                yaxis2: {title: 'Parte Imaginaria', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 3_3
            const traces3_3 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces3_3.push({
                    x: time,
                    y: mov.envelope.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Envolvente`,
                    line: {color: colors[ch], width: 2}
                });
                traces3_3.push({
                    x: time,
                    y: mov.phase.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1} Fase`,
                    line: {color: colors[ch], width: 1, dash: 'dash'},
                    yaxis: 'y2'
                });
            }
            Plotly.newPlot('plot3_3', traces3_3, {
                title: 'Punto 3: Envolvente y Fase Instant√°nea',
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Envolvente', side: 'left'},
                yaxis2: {title: 'Fase (rad)', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 3_4
            const traces3_4 = [];
            for (let ch = 0; ch < 4; ch++) {
                traces3_4.push({
                    x: time,
                    y: mov.filtered_signal.map(s => s[ch]),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Canal ${ch+1}`,
                    line: {color: colors[ch], width: 1}
                });
            }
            const shapes3_4 = [];
            for (let i = 1; i < mov.n_events; i++) {
                shapes3_4.push({
                    type: 'line',
                    x0: i * 10,
                    x1: i * 10,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {color: 'gray', width: 2, dash: 'dash'}
                });
            }
            Plotly.newPlot('plot3_4', traces3_4, {
                title: `Punto 4: Divisi√≥n en ${mov.n_events} Ventanas de 10 segundos`,
                xaxis: {title: 'Tiempo (s)'},
                yaxis: {title: 'Amplitud'},
                shapes: shapes3_4,
                hovermode: 'closest'
            });
            
            // Plot 3_5
            const ampValues3 = [];
            const phaseValues3 = [];
            for (let e = 0; e < mov.n_events; e++) {
                const ampRow = [];
                const phaseRow = [];
                const pairs = [[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]];
                pairs.forEach(([ch1, ch2]) => {
                    ampRow.push(mov.amp_connectivity[e][ch1][ch2]);
                    phaseRow.push(mov.phase_connectivity[e][ch1][ch2]);
                });
                ampValues3.push(ampRow);
                phaseValues3.push(phaseRow);
            }
            const traces3_5_amp = channelPairs.map((pair, idx) => ({
                x: Array.from({length: mov.n_events}, (_, i) => i + 1),
                y: ampValues3.map(row => row[idx]),
                type: 'scatter',
                mode: 'lines+markers',
                name: `Amp ${pair}`
            }));
            const traces3_5_phase = channelPairs.map((pair, idx) => ({
                x: Array.from({length: mov.n_events}, (_, i) => i + 1),
                y: phaseValues3.map(row => row[idx]),
                type: 'scatter',
                mode: 'lines+markers',
                name: `Fase ${pair}`,
                yaxis: 'y2'
            }));
            Plotly.newPlot('plot3_5', [...traces3_5_amp, ...traces3_5_phase], {
                title: 'Punto 5: Correlaci√≥n y Sincronizaci√≥n de Fase',
                xaxis: {title: 'Ventana Temporal'},
                yaxis: {title: 'Correlaci√≥n de Amplitud', side: 'left'},
                yaxis2: {title: 'PLV', side: 'right', overlaying: 'y'},
                hovermode: 'closest'
            });
            
            // Plot 3_6
            const matrixDiv3 = document.getElementById('plot3_6');
            if (matrixDiv3) {
                matrixDiv3.innerHTML = '<div class="matrix-grid"></div>';
                const grid3 = matrixDiv3.querySelector('.matrix-grid');
                if (grid3 && mov.amp_connectivity) {
                    for (let e = 0; e < mov.n_events; e++) {
                        const item = document.createElement('div');
                        item.className = 'matrix-item';
                        const matrixId = `matrix3_${e}`;
                        item.innerHTML = `<h4>Evento ${e+1}</h4><div id="${matrixId}" style="width: 100%; height: 100%; min-height: 300px;"></div>`;
                        grid3.appendChild(item);
                        setTimeout(() => {
                            Plotly.newPlot(matrixId, [{
                                z: mov.amp_connectivity[e],
                                type: 'heatmap',
                                colorscale: 'Viridis',
                                colorbar: {title: 'Correlaci√≥n', len: 0.6},
                                text: mov.amp_connectivity[e].map(row => 
                                    row.map(val => val.toFixed(2))
                                ),
                                texttemplate: '%{text}',
                                textfont: {size: 12}
                            }], {
                                title: `Evento ${e+1}`,
                                xaxis: {title: 'Canal', tickvals: [0, 1, 2, 3], ticktext: ['1', '2', '3', '4']},
                                yaxis: {title: 'Canal', tickvals: [0, 1, 2, 3], ticktext: ['1', '2', '3', '4']},
                                margin: {l: 60, r: 30, t: 40, b: 60},
                                autosize: true
                            }, {displayModeBar: false, responsive: true});
                        }, 10 * e);
                    }
                }
            }
            
            // Plot 3_7
            Plotly.newPlot('plot3_7', [{
                z: mov.amp_features,
                type: 'heatmap',
                colorscale: 'RdYlBu',
                colorbar: {title: 'Valor'},
                x: channelPairs,
                y: Array.from({length: mov.n_events}, (_, i) => `Evento ${i+1}`)
            }], {
                title: 'Punto 7: Matriz de Caracter√≠sticas',
                xaxis: {title: 'Caracter√≠sticas (Pares de Canales)'},
                yaxis: {title: 'Eventos/Ventanas'}
            });
            
            plotsRendered.movement3 = true;
        }
        
        function renderClassification() {
            if (!data || plotsRendered.classification) return;
            const cls = data.classification;
            
            // PCA
            const pcaData = cls.pca.X_pca;
            const labels = cls.y_all;
            const colors_pca = ['red', 'blue', 'green'];
            const traces_pca = [];
            for (let i = 0; i < 3; i++) {
                const indices = labels.map((l, idx) => l === i ? idx : -1).filter(idx => idx !== -1);
                traces_pca.push({
                    x: indices.map(idx => pcaData[idx][0]),
                    y: indices.map(idx => pcaData[idx][1]),
                    type: 'scatter',
                    mode: 'markers',
                    name: `Movimiento ${i+1}`,
                    marker: {color: colors_pca[i], size: 8}
                });
            }
            Plotly.newPlot('plot_classification_pca', traces_pca, {
                title: 'PCA - An√°lisis de Componentes Principales',
                xaxis: {title: 'PC1'},
                yaxis: {title: 'PC2'},
                hovermode: 'closest'
            });
            
            // t-SNE
            const tsneData = cls.tsne.X_tsne;
            const traces_tsne = [];
            for (let i = 0; i < 3; i++) {
                const indices = labels.map((l, idx) => l === i ? idx : -1).filter(idx => idx !== -1);
                traces_tsne.push({
                    x: indices.map(idx => tsneData[idx][0]),
                    y: indices.map(idx => tsneData[idx][1]),
                    type: 'scatter',
                    mode: 'markers',
                    name: `Movimiento ${i+1}`,
                    marker: {color: colors_pca[i], size: 8}
                });
            }
            Plotly.newPlot('plot_classification_tsne', traces_tsne, {
                title: 't-SNE - Reducci√≥n de Dimensionalidad No Lineal',
                xaxis: {title: 'Dimensi√≥n 1'},
                yaxis: {title: 'Dimensi√≥n 2'},
                hovermode: 'closest'
            });
            
            // Matriz de confusi√≥n
            Plotly.newPlot('plot_classification_cm', [{
                z: cls.confusion_matrix,
                type: 'heatmap',
                colorscale: 'Blues',
                colorbar: {title: 'Conteo'},
                text: cls.confusion_matrix.map(row => row.map(val => val.toString())),
                texttemplate: '%{text}',
                textfont: {size: 16, color: 'white'}
            }], {
                title: 'Matriz de Confusi√≥n',
                xaxis: {title: 'Predicci√≥n', tickvals: [0, 1, 2], ticktext: ['Mov 1', 'Mov 2', 'Mov 3']},
                yaxis: {title: 'Real', tickvals: [0, 1, 2], ticktext: ['Mov 1', 'Mov 2', 'Mov 3']}
            });
            
            // Reporte de clasificaci√≥n (tabla)
            const report = cls.classification_report;
            const reportDiv = document.getElementById('plot_classification_report');
            let html = '<table><tr><th>Clase</th><th>Precision</th><th>Recall</th><th>F1-Score</th><th>Soporte</th></tr>';
            for (let i = 0; i < 3; i++) {
                const key = i.toString();
                html += `<tr><td>Movimiento ${i+1}</td><td>${report[key].precision.toFixed(3)}</td><td>${report[key].recall.toFixed(3)}</td><td>${report[key]['f1-score'].toFixed(3)}</td><td>${report[key].support}</td></tr>`;
            }
            html += `<tr><td><strong>Accuracy</strong></td><td colspan="4"><strong>${cls.accuracy.toFixed(3)}</strong></td></tr>`;
            html += `<tr><td>Macro Avg</td><td>${report['macro avg'].precision.toFixed(3)}</td><td>${report['macro avg'].recall.toFixed(3)}</td><td>${report['macro avg']['f1-score'].toFixed(3)}</td><td>${report['macro avg'].support}</td></tr>`;
            html += `<tr><td>Weighted Avg</td><td>${report['weighted avg'].precision.toFixed(3)}</td><td>${report['weighted avg'].recall.toFixed(3)}</td><td>${report['weighted avg']['f1-score'].toFixed(3)}</td><td>${report['weighted avg'].support}</td></tr>`;
            html += '</table>';
            reportDiv.innerHTML = html;
            
            plotsRendered.classification = true;
        }
    </script>
</body>
</html>

